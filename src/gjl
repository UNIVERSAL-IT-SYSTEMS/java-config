#!/usr/bin/env python -E
# -*- coding: UTF-8 -*-

# Copyright 2004-2011 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# $Header: $

from java_config_2 import __version__
from java_config_2.OutputFormatter import *
from java_config_2.EnvironmentManager import *
from java_config_2.VersionManager import *

from optparse import OptionParser, make_option, OptionValueError
import os
from os.path import basename
import sys, re

# Needs some cleanup!
# Someone please?

#atom_parser = re.compile(r".*([<>=]+)virtual/(jre|jdk)-([0-9\.*]+).*")
atom_parser = re.compile(r"([<>=]+)virtual/(jre|jdk)-([0-9\.*]+)")

#Depreciated.
def get_needed_target(pkg):
    highest_target = ""
    needs_jdk = False
    for pkg in verman.get_needed_packages(pkg):
        pkg_needs_jdk = False
        x = pkg.query("TARGET")
        try:
            target, pkg_needs_jdk = x
        except (ValueError, TypeError):
            target = x

        needs_jdk |= pkg_needs_jdk
        if highest_target:
            if target > highest_target:
                highest_target = target
        else:
            highest_target = target

    return highest_target, needs_jdk

def get_needed_target2(pkg):
    highest_target = ""
    needs_jdk = set()
    for pkg in verman.get_needed_packages(pkg):
        target = pkg.target()
        if highest_target < target:
            highest_target = target
        if isinstance( pkg, Virtual ):
            for vm in pkg.get_vms():
                needs_jdk.add(vm)
    
    return highest_target, needs_jdk

def get_pkg_args(package):
    missing_deps = set()

    classpath = manager.build_dep_path([package.name()], "CLASSPATH", missing_deps)
    library = manager.build_dep_path([package.name()], "LIBRARY_PATH", missing_deps)

    if len(missing_deps) > 0:
        for dep in missing_deps:
            printer._printError("Dependency package %s was not found!" % dep)

    return ':'.join(classpath), ':'.join(library)

def abort(msg):
    printer._printError(msg)
    sys.exit(1)

# Support function for get_vm2
# Unused at present
def get_needed_vms(pkg):
    virtuals = set()
    vms = set()
    for pkg in verman.get_needed_packages(pkg):
        try:
            x = pkg.query("VM")
            if atom_parser.match( x ):
                matches = atom_parser.findall( x )
                pkg_virtuals = set()
                if len(matches) > 1:
                    add_virtual_str_to_set( pkg_virtuals, matches )
                    virtuals.add( pkg_virtuals )
                else:
                    add_virtual_str_to_set(virtuals, matches)
            else:
                #split first.
                matches = x.split(' ')
                for match in matches:
                    vms.add( match )
        except EnvironmentUndefinedError:
            #Something bad has happened here
            break
    return virtuals, vms

# Support function for get_vm2
def add_virtual_str_to_set( s, arr ):
    for a in arr:
        s.add(a[0] + 'virtual/' + a[1] + '-' + a[2])


## ----------------------------------
## This is a new style get_vm function.  Instead of using a packages
## TARGET env var it uses there VM var.
## Unused at present
def get_vm2(pkg):
    targets, vms = get_needed_vms(pkg)
    if len(vms) == 0:
        search_vms = manager.get_virtual_machines()
    else:
        search_vms = vms
    
    if len( targets ) == 0:
        if manager.get_active_vm().name() in vms:
            return None
        else:
            for x in vms:
                if manager.get_vm(x) and not manager.get_vm(x).is_build_only():
                    return manager.get_vm(x)

    for target in targets:
        if not target_matches( target, manager.get_active_vm()):
            break
        return None

    for vm in search_vms:
        try:
            for target in targets:
                if not target_matches( target, vm ):
                    raise Exception("Not valid vm")
            avm = manager.get_vm(vm)
            if avm and not avm.is_build_only():
                return avm
        except:
            #Handle this better
            continue
    return None

def target_matches( target, vm ):
    if isinstance( target, str ):
        return verman.version_satisfies( target, vm )
    else:
        return target_matches_any( target, vm)
        
def target_matches_any( targets, vm ):
    accept = False
    for target in targets:
        accept |= verman.version_statisfies( target, vm )
    return accept

# Options:
def get_vm(pkg):
    target, needs_jdk = get_needed_target2(pkg)
    active_vm = manager.get_active_vm()
    if len( needs_jdk ):
        if active_vm.name() in needs_jdk:
            return None
        for x in needs_jdk:
            vm = manager.get_vm(x)
            if vm and not vm.is_build_only():
                return vm
    else:
        needed = ">=virtual/jre-%s" % ( target )
        if verman.version_satisfies( needed, active_vm) \
                and not active_vm.is_build_only():
            return None
        return verman.get_vm(needed)
    #if target:
    #    if needs_jdk:
    #        needed = ">=virtual/jdk-%s" % ( target ) # Need to dehardcode that for Virtuals...
    #    else:
    #        needed = ">=virtual/jre-%s" % ( target ) # Need to dehardcode that for Virtuals...
    #    if verman.version_satisfies(needed, manager.get_active_vm()):
    #        return None
    #    else:
    #        return verman.get_vm(needed)
    #else:
    #    return verman.get_vm(pkg.query("VM"))

def get_args(pkg):
    args=""

    classpath, library = get_pkg_args(pkg)
    if classpath:
        envcp = os.getenv('CLASSPATH')

        if envcp:
            classpath = ':'.join((envcp, classpath))

        args += ' -classpath %s' % (classpath)

    envlp = os.getenv('LD_LIBRARY_PATH')
    envjlp = os.getenv('JAVA_LIBRARY_PATH')

    newlibrary = manager.eprefix + '/lib:'+ manager.eprefix + '/usr/lib'
    if library:
        newlibrary = ':'.join((library, newlibrary))
    if envjlp:
        newlibrary = ':'.join((newlibrary, envjlp))
    if envlp:
        newlibrary = ':'.join((newlibrary, envlp))

    args += ' -Djava.library.path="%s"' % (newlibrary)

    if args:
        return args
    else:
        return None

def get_env(package):
    env = manager.build_dep_env_vars([package.name()], set())
    return env

def get_jar(pkg, gjar):
    jars = pkg.classpath()
    if jars:
        for jar in jars.split(':'):
            if gjar == basename(jar):
                return jar
            if normpath(gjar) == normpath(jar):
                return gjar
    return None

def normpath(mypath):
    newpath = os.path.normpath(mypath)
    if newpath.startswith('//'):
        return newpath[1:]
    return newpath

if __name__ == '__main__':
    usage =  "%prog [options]\n\n"
    usage += "Java Utility Version " + str(__version__) + "\n"
    usage += "Copyright 2004-2011 Gentoo Foundation\n"
    usage += "Distributed under the terms of the GNU General Public License v2\n"
    usage += "Please contact the Gentoo Java Herd <java@gentoo.org> with problems."

    options_list = [
                     make_option ("-p", "--package",  action="store", type="string", dest="package", help="The package"),
                     make_option ("-v", "--get-vm",   action="store_true", dest="get_vm"),
                     make_option ("-a", "--get-args", action="store_true", dest="get_args"),
                     make_option ("-j", "--get-jar", action="store", type="string", dest="jar")
                   ]

    parser = OptionParser(usage, options_list)
    (options, args) = parser.parse_args()

    eprefix = os.getenv('EPREFIX', '@GENTOO_PORTAGE_EPREFIX@')
    root = os.getenv('ROOT', '')

    global printer, manager, verman
    printer = OutputFormatter(True, True)
    manager = EnvironmentManager(root, eprefix)
    verman = VersionManager(manager)

    if not options.package:
        abort("Too dumb todo anything without -p")

    pkg = manager.get_package(options.package)
    if not pkg:
        abort("Invalid package: %s" % ( options.package ) )

    if options.get_vm:
        vm = get_vm(pkg)
        if vm:
            manager.set_active_vm(vm)
            print('gjl_vm="%s"' % ( vm ))

    if options.get_args:
        args = get_args(pkg)
        if args:
            print('gjl_args="%s";' % ( args ))
        env = get_env(pkg)
        for k, v in env.items():
            if 'PATH' in k:
                print('export %s="%s:${%s}"; %s=${%s%%:};' % ( k, v, k, k, k )).strip(':')
            else:
                print('export %s="%s";' % ( k, v ))

    if options.jar:
        jar = get_jar(pkg, options.jar)
        if jar:
            print('gjl_starte="-jar %s"' % ( jar ))
        else:
            abort("Couldn't find %s" % ( options.jar ) )

# vim:set expandtab tabstop=4 shiftwidth=4 softtabstop=4 nowrap:
